# 9월 05일 TIL

## 실행컨텍스트

- 실행할 코드에 제공할 환경 정보들을 모아 놓은 환경
  - 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(호이스팅),
  - 외부 환경정보를 구성하고,
  - this 값을 설정하는 등의 동작을 수행합니다.
  - 필요한 정보를 모아 실행 컨텍스트를 만들고, 실행 컨텍스트 스택에 쌓아 올린 후 코드 실행을 시작합니다.

## 실행컨텍스트의 3가지 객체

> 실행 컨텍스트 구성할 때 생기는 것들

- VariableEnvironment(변수환경): 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보
- LexicalEnvironment(렉시컬환경): 현재 컨텍스트 내의 식별자들에 대한 정보
- ThisBinding: this 식별자가 바라봐야 할 대상 객체

> 전역객체(window etc...)는 코드가 평가되기 전에 생성된다.

## 호이스팅

- 자바스크립트는 코드를 실행하기 전 식별자들을 수집 및 정리하는 과정을 거칩니다.
- 즉, 실행 컨텍스트에 속한 변수명을 모두 알고 있어야 하고
- 이를 위해 변수명을 먼저 수집하는데, 이 과정에서 변수의 선언문을 끌어올리는 것처럼 보이게 되는 것이 호이스팅 입니다.
- 호이스팅은 식별자가 자기가 속한 스코프의 최상단에 끌어 올려 지는 것을 의미 합니다.
  - 이때 var, let, const, function, class 는 모두 호이스팅이 되며
  - let, const, 함수 선언식은 코드에서 할당되기 전까지 tdz(Temporal Dead Zone)에 빠지게 됩니다.

## 스코프

- 스코프는 식별자(변수 이름, 함수 이름, 클래스 이름)가 자신이 선언된 위치에 따라 다른 코드에 의해 참조될 수 있는 유효 범위를 말합니다.
- 자바스크립트 엔진은 스코프를 통해 어떤 식별자를 참조해야 할 것인지 결정합니다.
  - 전역 스코프 : 코드 어디에서든지 참조할 수 있는 스코프
  - 지역 스코프 : 블록레벨 스코프, 함수레벨 스코프가 있으며
    - 블록레벨 스코프는 중괄호로 둘러싸인 코드 블록 내에서만 참조할 수 있는 스코프
      - ex) if, for, while, try/catch
    - 함수레벨 스코프는 함수 내부에서만 참조할 수 있는 스코프
      - ex) 함수 내부에서 선언된 변수는 함수 외부에서 참조할 수 없습니다.

## 스코프 체인

- 스코프가 게층적으로 연결된 것을 스코프 체인이라고 합니다.
- 스코프 체인(Scope Chain)은 실행 컨텍스트의 일부로, 현재 실행 중인 코드가 변수와 함수에 접근할 수 있는 범위를 정의합니다. 간단히 말해, 스코프 체인은 변수에 접근할 수 있는 스코프의 계층적인 목록을 제공합니다.
- 자바스크립트에서는 함수를 호출할 때마다 새로운 실행 컨텍스트가 생성되며, 이 때마다 해당 함수가 접근할 수 있는 변수나 함수에 대한 정보가 스코프 체인에 저장됩니다. 스코프 체인은 현재 실행 컨텍스트의 변수 객체를 시작으로, 외부 스코프로 연결되어 있는 리스트 구조입니다.
- ![Title](https://camo.githubusercontent.com/c958f56eb1be5ca4d321a4df6ce0e2a961feff08aa66b3c9d537ce77565ecf1e/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d616765732f73736f7269303432312f706f73742f63633139633864632d373031342d343938352d386132322d3132376331613365396366652f696d6167652e6a7067)

- 변수 참조

  - 자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 변수를 검색합니다.
  - 이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없음을 의미합니다.

## 동적 스코프 vs 렉시컬 스코프

- 함수의 상위 스코프 결정
  - 동적스코프
    - 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정합니다.
  - 렉시컬 스코프
    - 함수가 어디서 정의 되었는지에 따라 함수의 상위 스코프를 결정합니다. - js

## 클로저 - 자신이 선언될 당시의 환경을 기억하는 함수

- 중첩함수가 상위 스코프의 식별자를 참조하면서, 외부함수보다 오래 유지되는 함수를 클로저라고 합니다.
- 클로저 중첩함수는 자신이 정의된 위치에 의해 결정된 상위 스코프를 기억하고 참조할 수 있습니다.
- 클로저에 의해 참조되는 식별자는 더 이상 참조되지 않을때까지 살아 남습니다.

```javascript
function outer() {
  var a = 1;
  var inner = function () {
    return ++a;
  };
  return inner; // inner 함수를 반환(오래 살아남음)
}
```

## this

- 자바스크립트의 this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이며, 호출된 위치에 따라 결정되는 값입니다.

- 전역에서 this는 window를 가리킵니다.
- 함수선언문 내부에서 this를 호출하게 되면 window이며,
- 함수표현식(화살표함수)에서는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되어 상위함수의 this값을 가져옵니다.

- new 연산자를 이용한 생성자 함수 방식으로 인스턴스를 생성 하면 this는 함수 내부의 this를 가리킵니다.

- 객체의 내부에서 this는 객체 값을 참조합니다.

- 고차 함수의 callback 안에서는 callback이 일반함수 이므로 전역객체를 참조합니다. 이때 콜백함수의 다음인자로 참조할 객체를 전달해 줄경우 this값을 해당 객체 값을 참조합니다.
  - 고차 함수는 다른 함수를 매개 변수로 받거나 함수를 반환하는 함수를 가리킵니다

## promise

- 비동기 처리를 위한 객체로
- 비동기 작업이 끝난 후의 결과값이나 실패 이유를 처리하기 위해 사용합니다.
- promnise의 상태
  - pending
  - settled (fulfilled or rejected)
    - fulfilled
    - rejected
- promise 객체는 then, catch, finally 메서드를 통해 상태에 따른 처리를 할 수 있습니다.

## prototype

- js는 prototype 기반 언어로 객체 지향 프로그래밍에서의 상속과 비슷한 개념을 js에서 구현하기위한 메커니즘입니다.
- js의 객체는 prototype이라는 객체를 가지고 있으며, 이 객체는 상위 객체를 가리킵니다.

- JavaScript의 prototype은 객체 지향 프로그래밍에서 상속과 비슷한 개념을 JavaScript에서 구현하는 메커니즘이라고 볼 수 있습니다. JavaScript는 프로토타입 기반 언어입니다,
- 클래스가 아닌 프로토타입을 통해 객체의 속성과 메서드를 상속합니다.
- JavaScript에서 모든 객체는 내부적으로 [[Prototype]]이라는 특수한 속성을 가지고 있습니다.
- [[Prototype]] 속성은 그 객체의 "부모" 역할을 하는 다른 객체를 가리킵니다.
- 어떤 객체에서 속성이나 메서드를 찾을 수 없을 때, JavaScript는 자동으로 그 객체의 프로토타입(즉, [[Prototype]]이 가리키는 객체)을 찾아 그 속성이나 메서드가 있는지 확인합니다.

## ajax

- AJAX(Ajax Asynchronous JavaScript and XML)는 클라이언트와 서버 간에 비동기적으로 데이터를 교환할 수 있는 웹 기술입니다.

## class

## 비동기, Ajax

## 이벤트 루프

b cv

## 콜백함수

## 프로미스

- 비동기 콜백 패턴의 문제 때문에 나옴
- 비동기의 처리 상태(pending, settled(fufiled, rejected))와 결과 값을 객체로 나타낸 것

## CSS에서 position이란?

- position 속성은 문서 상에 요소를 배치하는 방법을 지정합니다.
- static: 요소를 일반적인 문서 흐름에 따라 배치합니다.

  - relative: static + 자신을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용합니다.
  - absolute: 요소를 일반적인 문서 흐름에서 제거하고, 가장 가까운 위치 지정 조상 요소에 대해 상대적으로 배치합니다.
  - fixed: 요소를 일반적인 문서 흐름에서 제거하고, 뷰포트의 초기 컨테이닝블록을 기준으로 삼아 배치합니다. => 바뀌지 않는 위치에 지정
  - sticky: static + fixed 특징을 동시에 가집니다.

    - ⚙️ 뷰포트
      뷰포트(viewport)는 화면에서 실제 내용이 표시되는 영역으로, 데스크톱은 사용자가 설정한 해상도가 뷰포트 영역이 되고, 스마트 기기는 기본으로 설정되어 있는 값이 뷰포트 영역이 됩니다.

    - ⚙️ 컨테이닝블록
      컨테이닝 블록이란 요소의 위치와 크기를 지정하는 데 사용하는 블록을 의미합니다. 상대적인 값이나, 요소의 위치를 지정하는 기준이 필요할 때 사용한다는 의미힙니다.

## CSS에서 float이란?

- float 속성은 요소를 일반적인 흐름에서 빼내어 배치합니다.

## class vs id

- 클래스와 아이디는 CSS에서 선택자로 사용되는 속성으로, 클래스는 여러 요소에 스타일을 공유하거나, 특정 요소에 여러 스타일을 적용하기 위해 사용되며,
- 아이디는 고유한 식별자로서 하나의 요소에만 스타일을 적용하는 데 사용됩니다.

# REACT

## 컴파운드 패턴

- https://itchallenger.tistory.com/266

## react LifeCycle

![](https://cdn.filestackcontent.com/ApNH7030SAG1wAycdj3H)

- 마운트(componenetDidMount)

  - 컴포넌트가 DOM에 삽입될 때 호출됩니다.
  - 이 메서드 내에서 다른 JavaScript 프레임워크를 연동하거나, setTimeout, setInterval 및 AJAX 처리 등을 넣습니다.

- 업데이트(componentDidUpdate)

  - props혹은 state가 변경되거나 forceUpdate()가 호출되었을 때 리랜더링을 하는 과정
  - getDerivedStateFromProps
  - shouldComponentUpdate
  - render
  - getSnapshotBeforeUpdate

- 언마운트(componentWillUnmount)
  - 컴포넌트가 DOM에서 제거될 때 호출됩니다.
  - 이 메서드 내에서 타이머 제거, 네트워크 요청 취소, componentDidMount()에서 생성된 구독 해제 등 필요한 모든 정리 작업을 수행합니다.
  - 함수형에서는 useEffect의 return을 통해 구현합니다.

## PureComponent

- PureComponent는 shouldComponentUpdate를 자동으로 구현해줍니다.

## react 가상돔(virtual Dom)이란?

- 리엑트의 가상돔은 실제 DOM과 같은 내용을 담고 있는 복사본이다. 이 복사본은 자바스크립트 객체로 메모리상에 저장되어 있습니다.
- 리엑트는 2개의 가장 돔을 가지고 있고 이 두개의 가상돔을 비교하여 변경된 부분만 실제 돔에 반영합니다.
- 변경된 내용이 화면에 새롭게 그려지기 이전
- diffing을 통해 빠르게 변경된 부분만 실제 돔에 반영이 되어 집니다.(reconciliation)
- Diffing을 통해서 변경된 부분들을 파악한 이후에 리액트는 Batch Update를 통해 한번에 업데이트를 진행합니다. 이 과정을 Reconciliation이라고 합니다.
- 가상돔을 사용하는 이유는 실제 돔을 직접 조작하는 것보다 가상돔을 조작하는 것이 훨씬 빠르기 때문입니다.

## state vs props

- state는 컴포넌트 내부에서 선언되며, 내부에서 값을 변경할 수 있습니다.
- props는 컴포넌트 외부에서 전달되며, 컴포넌트 내부에서 변경할 수 없습니다.

## forwardRef란

- 컴포넌트에 ref를 전달할 수 있게 해주는 기능입니다.

```jsx
function App() {
  const ref = useRef(null);
  const focus = () => {
    ref.current.focus();
  };
  return (
    <>
      <MyInput ref={ref} />
      <button onClick={focus}>포커스</button>
    </>
  );
}

const MyInput = (props, ref) => {
  return <input ref={ref} {...props} />;
};
export default React.forwardRef(MyInput); // 컴포넌트를 forwardRef로 감싸준다.
```

# TypeScript

## 유틸리티타입

- 유틸리티타입

  1. Pick

  ```tsx
  type TodoPreview = Pick<Todo, 'title' | 'completed'>;
  ```

  2. **Omit<T, K>**: **`Pick`**과 반대로 작동합니다. 특정 타입에서 몇 가지 속성을 제거한 새로운 타입을 만듭니다.

  ```tsx
  typescriptCopy code
  type TodoInfo = Omit<Todo, "completed">;
  ```

  3. **Partial<T>**: 객체의 모든 속성을 optional로 만드는 새로운 타입을 생성합니다.

  ```tsx
  typescriptCopy code
  type OptionalTodo = Partial<Todo>;

  ```

  4. **Readonly<T>**: 객체의 모든 속성을 읽기 전용으로 만드는 새로운 타입을 생성합니다.

  ```tsx
  typescriptCopy code
  type ImmutableTodo = Readonly<Todo>;

  ```

  5. **Record<K, T>**: 속성 키들의 집합과 값을 연결하여 새로운 타입을 만듭니다.

  ```tsx
  typescriptCopy code
  type PageInfo = Record<"home" | "about" | "contact", string>;

  ```

  6. **Exclude<T, U>**: **`T`** 타입에서 **`U`**에 할당 가능한 것들을 제외한 타입을 만듭니다.

  ```tsx
  typescriptCopy code
  type NotBoolean = Exclude<"a" | "b" | boolean, boolean>;

  ```

  7. **Extract<T, U>**: **`T`** 타입에서 **`U`**에 할당 가능한 것들만 추출한 타입을 만듭니다.

  ```tsx
  typescriptCopy code
  type StringOrNumber = Extract<"a" | "b" | 1 | 2, string | number>;

  ```

  이러한 유틸리티 타입들은 복잡한 타입 작업을 매우 단순화시켜주며, 재사용성과 가독성을 향상시킵니다.

# CSS

## px rem em

## CSS 선택자

## css 우선 선택 순위

# CS

## 주소창에 [www.google.com](http://www.google.com)을 입력하면 일어나는 일

- 입력한 도메인을 DNS 서버에서 검색하기 전에 브라우저는 캐싱된 DNS 기록을 확인하여 IP 주소를 찾습니다. 캐싱된 값이 없을 경우, DNS 서버에 요청을 보냅니다.

  - DNS 서버는 해당 도메인의 IP 주소를 브라우저에 전달해줍니다.
  - 이 IP 주소를 통해 브라우저는 TCP 연결을 성립한 후 HTTP/HTTPS 프로토콜을 이용하여 웹 서버에 요청을 보냅니다.
  - 웹 서버는 이 요청에 대한 응답으로 HTML, CSS, JS, 이미지 파일 등을 브라우저로 전송합니다.
  - 브라우저는 HTML 파일을 파싱하여 DOM 트리를 구축하고, CSS 파일을 파싱하여 CSSOM 트리를 만듭니다.
  - 이 두 트리를 결합하여 렌더 트리를 구축합니다.
  - 만약 자바스크립트가 실행되면서 DOM이나 CSSOM에 변화를 준다면, 렌더 트리는 업데이트되고 Reflow와 Repaint 과정을 거쳐 최종적으로 브라우저 화면에 렌더링됩니다.”

## 함수형 프로그래밍

- 함수형 프로그래밍은 계산을 수학적 함수의 평가로 취급하고 상태 및 가변 데이터 변경을 방지하는 프로그래밍 패러다임이다.
- 함수형 프로그래밍에서 함수는 변수에 할당되고 다른 함수에 인수로 전달되고 다른 함수의 결과로 반환될 수 있음을 의미하는 일등 시민(first-class citizens)으로 취급된다. 함수형 프로그래밍의 특징은 다음과 같다.

  - 불변성
    함수형 프로그래밍은 불변 데이터를 선호하여, 값이 할당되면 변경할 수 없다. 원본 데이터를 수정하는 대신 복사본을 사용하여 새 데이터 구조를 만든다.
  - 순수 함수
    동일한 입력에 대해 동일한 출력을 생성한다.
    외부 상태를 수정하거나 변경 가능한 데이터에 의존하지 않는다(no side effect).
  - 고차 함수
    다른 함수를 인수로 사용하거나 함수를 결과로 반환할 수 있다. 이를 통해 강력한 추상화가 가능하고 보다 일반적이고 재사용 가능한 코드를 작성할 수 있다.
  - 재귀
    함수형 언어의 반복은 재귀에 의해 구현된다. 재귀 함수는 종료 조건이 충족될 때까지 수정된 매개변수로 자신을 호출한다.
    기능 구성
    기능적 프로그래밍은 기능을 함께 연결하여 보다 복잡한 작업을 형성함으로써 기능을 구성한다. 이를 통해 한 함수의 출력이 다음 함수의 입력이 되는 파이프라인을 구성할 수 있다.

## cors

- 브라우저에서 동일 출처 정책(Same-Origin Policy)에 의해 다른 출처의 리소스가 제한 되는 메커니즘을 나타냅니다
- Access-Control-Allow-Origin 헤더를 통해 다른 출처의 리소스를 요청할 수 있습니다.

## Rest Api

- URL에서는 동사를 쓰지 않는다. ex) /createMovie -> /movie
- HTTP methods를 활용하여 인터렉션
  - GET, POST, PUT, DELETE

## 브라우저의 렌더링 원리

## reflow, repaint

## google.com입력하면 일어나는 일

# ETC

## 프로그래밍 패러다임

- 프로그래밍 패러다임은 개발자에게 프로그래밍의 관점을 갖고 결정하는 역할을 한다.
- 명령형 프로그래밍
  - 구문의 관점에서 상태를 바꾸는 방식으로 연산을 설명
    - 절차지향 프로그래밍 - 수행되어야 할 연속적인 계산 과정을 포함하는 방식
    - 객체 지향 프로그래밍 - 객체들의 집합으로 프로그래밍을 표현
- 선언적 프로그래밍
  - 어떤 방법으로 해야하는지(how)보다 무엇(what)과 같은지를 설명하는 방식
    - 함수형 프로그래밍 : 순수함수를 조합하고 소프트웨어를 만드는 방식
      - 1급 객체(first class object) ex) js 에서 함수는 객체이므로 1급 객체이다.
        - 변수나 데이터 구조안에 담을 수 있다
        - 파라미터로 전달 할 수 있다.
        - 반환값으로 사용할 수 있다.
        - 동적으로 프로퍼티 할당이 가능하다
      - 고차 함수(higher order function) : 함수를 인자로 받거나 함수를 반환하는 함수
        - 함수에 함수를 파라미터로 전달 할 수 있다.
        - 함수의 반환값으로 함수를 사용할 수 있다.

# 참조

https://www.jsv9000.app/?utm_source=substack&utm_medium=email

```

```

1. reactQuery cachingTime 사용해본적 있는지, 있다면 업데이트가 필요한경우 어떻게 caching된 데이터를 다시 불러 왔는지
2. 리액트 컴파운드 패턴
3. input의 defaultValue와 value 의 차이 (controlld, uncontrolled)
4. forwardRef 사용 해본적이 있는지
5. recoil의 데이터는 어떤걸 저장하였는가
6. contextApi를 사용한경우
7. 다른 언어 사용해 본것과 타입스크립트를 비교해 달라
8. input의 포커스를 관리하는 경우 input을 컴포넌트로 만들었을때는 input의 포커스는 어떻게 관리를 하였는가
